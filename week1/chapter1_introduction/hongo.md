# 운영체제가 하는 일
사용자와 하드웨어 사이를 중재하는 소프트웨어이다.
![](https://velog.velcdn.com/images/hgo641/post/01482390-d332-4589-a20d-060b8f72a540/image.jpeg)

응용 프로그램은 워드프로세서, 크롬 등 사용자를 위한 프로그램이다. 응용 프로그램들은 하드웨어로부터 CPU, 메모리 공간 등 리소스를 얻어와야 하는데, 운영체제가 각 프로그램들이 얻는 리소스들을 관리한다.


## 커널
커널은 운영체제의 핵심 요소로, 컴퓨터가 켜지면 항상 메모리에서 상주하는 부분이다. (운영체제는 보통 커널과 같은 의미로 쓰인다고 한다. 넓은 의미의 운영체제는 사용자 인터페이스 기능까지 포함한 형태)

커널은 CPU, 메모리, 디스크, 입출력 장치의 자원을 관리한다. 하드웨어 자원들을 쉽게 관리하기 위해 추상화해서 제공한다.

```java
물리적 자원  ->   추상화
* CPU     ->  Task
* Memory  ->  Page, Segment
* Disk    ->  File
* Network ->  Socket
```

### 이중모드(사용자 모드와 커널 모드)
CPU가 명령을 실행하는 모드는 두 가지가 있다.
* 사용자 모드
  * 운영체제 서비스를 제공받을 수 없는 실행모드
  * = 커널 영역의 코드 실행 불가능
  * = 하드웨어 자원에 접근 불가능
  * 응용 프로그램이 기본적으로 사용자 모드에서 실행됨

* 커널 모드
   * 운영체제 서비스를 제공받을 수 있는 실행모드
   * = 커널 영역의 코드 실행 가능
   * = 하드웨어 자원에 접근 가능

* 왜 두 가지 모드로 나누었을까?
   * 두 가지 모드로 나눈 이유는, 사용자가 중요한 리소스에 접근하는 것을 막기 위해서라고 한다.

응용 프로그램은 사용자 모드에서 커널 모드로 전환하기 위해 `시스템 콜(시스템 호출)`을 사용한다. 시스템 콜은 운영체제 서비스를 제공받기 위한 요청으로, 소프트웨어 인터럽트라고 볼 수 있다. (인터럽트는 아래에서 서술)

## 인터럽트

인터럽트에 대해 알기 전, 입출력 장치같은 하드웨어가 어떻게 소프트웨어와 통신하는지 간략하게 알아보자.

각 하드웨어 장치는 `장치 컨트롤러`와 연결되어 있다. 장치 컨트롤러는 하드웨어의 규격을 맞추고, CPU와 하드웨어(입출력장치)간 전송률이 차이나는 것을 극복하기 위해 버퍼링등의 기능을 제공한다. 하드웨어로 접근하기 위한 인터페이스라고 보면 될 것 같다.

장치 컨트롤러가 하드웨어로 접근하기 위한 인터페이스용이라면, `장치 드라이버`는 소프트웨어에 접근하기 위한 인터페이스이다. 장치 드라이버는 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게하는 `프로그램`이다. (장치 컨트롤러는 하드웨어, 장치 드라이버는 소프트웨어) 

각 장치 컨트롤러마다 장치 드라이버가 있으며, 장치 드라이버가 작업을 위한 값을 장치 컨트롤러의 레지스터에 넘겨준다. 장치 컨트롤러는 하드웨어에 접근해 해당 작업을 수행한 후 결과를 장치 드라이버에게 넘겨준다.

```
입출력 작업을 예시로 들면,
1. 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재한다.
2. 장치 컨트롤러는 레지스터 내용을 검사하여 수행할 작업을 결정한다.(ex. 키보드에서 문자 읽기)
3. 장치 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
4. 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다.
5. 장치 드라이버는 데이터 또는 데이터에 대한 포인터를 반환하여 운영체제의 다른 부분에 제어를 넘긴다.
```

**장치 컨트롤러는 어떻게 장치 드라이버에게 작업이 완료되었음을 알리는 걸까? 바로 인터럽트라는 것을 사용한다.**

인터럽트를 통해 운영체제와 하드웨어의 상호 작용을 할 수 있다.

각 인터럽트는 적절한 ISR(인터럽트 서비스 루틴)을 가지고 있고, ISR은 인터럽트를 처리하기 위한 코드 모음이라고 된다. (ISR은 메모리에 존재하며, 커널의 일부라고 볼 수 있다.)

인터럽트가 자주 발생하기에, 인터럽트들은 ISR을 가리키는 포인터에 빠르게 접근할 수 있는 테이블을 메모리에 저장하고 있다. 이 테이블을 `인터럽트 벡터 테이블`이라고 한다.

![](https://velog.velcdn.com/images/hgo641/post/3a53476d-ced7-4753-b1f8-6975855c488b/image.jpeg)


CPU와 장치 컨트롤러는 같은 버스를 사용해서 메모리에 접근한다. 때문에 CPU에서 수행되는 작업과 장치 컨트롤러가 수행한 작업은 병렬로 실행되며 메모리 사이클을 놓고 경쟁한다.

```
버스란?
컴퓨터 시스템 구성요소들을 상호 연결하는 중심 통로
```

그렇기에, 장치 컨트롤러가 처리한 결과를 장치 드라이버가 처리하기 위해선 기존에 CPU가 처리하고 있던 작업을 잠시 멈추고 끼어들 필요가 있다.

![](https://velog.velcdn.com/images/hgo641/post/dc623a15-8624-4bf6-8f2b-2b7ce95a0d5d/image.jpeg)


그림을 보며 인터럽트 과정을 알아보자.
장치 컨트롤러는 인터럽트 작업을 요청할 때 `인터럽트 리퀘스트 라인`이라는 것에 기록한다. CPU는 명령어를 하나 실행할 때마다 이 라인을 확인하며 인터럽트 요청이 왔는지를 체크한다.

인터럽트 요청이 왔다면, CPU는 인터럽트 벡터 테이블을 통해 적절한 ISR을 찾는다. ISR은 기존에 처리하고 있던 작업의 정보를 ProgramCounter에 저장하고, 인터럽트 작업을 수행한다. 작업을 완료하면 ISR은 이전에 처리하고 있던 작업으로 상태를 복구한다.


> **ISR(인터럽트 서비스 루틴) vs 인터럽트 핸들러**
두 용어가 자주 나오는데, 수행하는 기능이 같은 것 같아 혼란스러웠다. 검색해보니 ISR은 주로 하드웨어와 관련된 용어로서 저수준에서 동작하는 코드를 나타내는 반면, 인터럽트 핸들러는 소프트웨어 및 운영체제의 관점에서 인터럽트를 처리하는 데 사용되는 더 포괄적인 용어라고 한다. 
같은 의미로 사용해도 무방할 것 같다.

### 더욱 정교한 인터럽트 처리

똑똑한 개발자들은 더 정교한 인터럽트 처리를 위해 아래 세 가지 고민을 했다.

1. CPU가 중요한 작업을 처리 중일 때, **인터럽트 처리를 미룰 수 있어야한다.**
2. **더 효율적으로 인터럽트 핸들러로 디스패치 할 수 없을까?**
3. **인터럽트에 우선순위를 부여할 수 없을까?**

인터럽트 처리를 미루기 위해, 인터럽트는 **미룰 수 있는 것**과 **미룰 수 없는 것** 두 분류로 나눠졌다. 미룰 수 있는 인터럽트를 **마스킹 가능** 이라고 하고, 미룰 수 없는 인터럽트를 **마스크 불가능 인터럽트**라고 부른다. 당연한 얘기지만, 마스크 불가능 인터럽트에는 메모리 오류와 같이 복구할 수 없는 크리티컬한 인터럽트가 속한다.
그리고 CPU에 마스킹 가능한 인터럽트를 감지하는 핀과, 마스킹 불가능한 인터럽트를 감지하는 핀을 별도로 두어 구분해서 처리한다고 한다.

![운영체제 3](https://github.com/splitCoding/CS-Study/assets/65850682/b41f0db5-b676-4532-9a77-1127c8347301)
각 인터럽트는 위 사진처럼 번호가 붙여져있는데, 번호가 작을수록 우선순위가 높은 인터럽트임을 의미한다고 한다. 
(위 사진은 Intel 처리기 이벤트의 벡터 테이블인데 CPU 내부에서 발생하는 인터럽트들이고, CPU 외부에서 발생하는 PC 시점의 인터럽트들에 대한 테이블은 또 별도로 있음. CPU 내부 인터럽트들은 instruction과 동기화되어서 발생하기에 ynchronous interrupt라고 부르고, CPU 외부 인터럽트들은 asynchronous interrrupt라고 부른다고 함.)


또한, 인터럽트 벡터의 주소 개수보다 많은 양의 장치가 존재하기에, 인터럽트 체인을 사용한다고 한다... (인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리키고, 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 하나씩 검사한다는데... 트리처럼 인터럽트 범위를 나누고 연결리스트형식으로 검사한다는 건가?)

# 컴퓨터 시스템 구조

## 컴퓨터 저장장치 구조
![](https://velog.velcdn.com/images/hgo641/post/11771ea5-b1ea-4dae-a8ef-b5258b34f2d3/image.jpeg)

* 비휘발성 메모리(NVM)에는 플래시 메모리, SSD등이 있다
* 보조 기억 장치(2차 저장장치)는 기계적 저장장치와 전기적 저장장치로 나뉜다? 기계적 저장장치가 HDD, 전기적 저장장치가 NVM...
* 3차 저장장치는 백업용도정도로만 사용돼서 속도가 서비스에 큰 영향을 끼치지 않음. 1차와 2차간의 속도 개선이 가장 중요. 그래서 캐시
* 컴퓨터가 켜질 때 가장 먼저 실행되는 프로그램을 부트스트램 프로그램이라고 하는데, 이 프로그램이 보조기억장치에 있는 운영체제 프로그램을 메모리에 적재한다. 

### 입출력 구조
이전 포스팅에서 인터럽트에 대해 설명했는데, 인터럽트는 소량의 데이터를 이동하는 데 좋음. 그런데 대량의 보조 기억 장치 IO가 발생하면 인터럽트로는 과부화가 걸릴수도 있음. 이를 해결하기 위해 `직접 메모리 엑세스(DMA)`라는 것도 있다...
장치 제어기?가 CPU 개입없이 메모리로부터 자신의 버퍼장치로, 또는 버퍼장치에서 메모리로 데이터를 블록(이 몇임? 페이지임?)단위로 옮긴다는데 더 찾아봐야 할 듯.

### 단일 처리기 시스템(싱글 프로세서 시스템)
현대에 잘 쓰이진 않음. 
하나의 코어를 가진 하나의 CPU를 사용하는 시스템 구조임. 근데 코어를 가진 메인 CPU프로세서가 하나라는 거고, 다른 프로세스들은 또 있는듯.
특정 장치를 위한 용도로만 사용되는 프로세스를 의미ㅇㅇ. 메인 cpu는 하나... (ex. 디스크 컨트롤러 마이크로프로세스 : 디스크 관리에만 신경씀. 디스크 큐 스케줄링 등)

### 다중 처리기 시스템(멀티 프로세서 시스템)
> 용어 정리
* CPU - 명령을 실행하는 하드웨어
* 프로세서 - 하나 이상의 CPU를 포함하는 물리적인 칩
* 코어 - CPU의 기본 계산 단위
* 다중 코어(멀티코어) - 하나의 CPU에 여러 개의 코어~
* 다중 처리기(멀티프로세서) - 프로세서가 여러 개~

![](https://velog.velcdn.com/images/hgo641/post/83787bfd-8ba2-4198-8d64-dad1ca981ee0/image.jpeg)

하나의 코어를 가진 CPU가 여러개씩 있음. (다중 코어를 가진 CPU도 포함하는 개념이긴함)
메모리나 주변장치의 데이터를 여러 개의 프로세서가 공유할 수 있음. 근데 CPU칩 내부에 별도로 존재하는 레지스터와 캐시가 존재하기 때문에 얘네는 값이 달라지는 경우가 생길 수도 있음. 정합성 문제ㅇㅇ. 근데 어떻게 해결하고 있는진 아직 안알려줌.

프로세서가 N개 있으면 N개의 프로세스를 동시에 처리할 수 있어서 처리량 늘어남. 물론 처리량이 무조건 N배 증가하는 건 아니고, 공유자원에 대한 경합등의 문제로 오버헤드는 존재함. 그래서 너~~무 많이 증설하면 오히려 성능이 떨어질 수도 있음. 

![](https://velog.velcdn.com/images/hgo641/post/9fc2de72-003f-49c8-9bb6-a0df45a38e64/image.jpeg)
이렇게 하나의 프로세서 안에 코어가 여러 개 있는 경우도 있는 건 `다중 코어 시스템`이라고 하는데, 다중 처리기 시스템에 포함되는 개념임. 칩 내 통신보다 칩 안에서만 통신하는 게 더 빨라서 위에 구조보다 더 효율적임. 


모든 CPU가 공유 시스템 연결로 연결되어 하나의 물리주소 공간을 공유하는 NUMA라는게 있다... 자세한 건 잘 모르겠음 헷

## 클러스터형 시스템
노드(컴퓨터?)단위로 네트워크를 통해 여러 개의 컴퓨터를 연결한 것을 말하는 거라고 이해함.
한 노드가 죽어도 다른 노드에서 작업을 수행할 수 있기에 가용성 높은 구조. 두 가지 버전이 있음
* 비대칭형 클러스터링 : 특정 노드는 작업 안하고, 작업중인 서버가 죽었는지 아닌지만 검사하고 있음. 다른 서버가 죽었다면 얘가 승격함. 긴급 대기 모드라고 부름
* 대칭형 클러스터링 : 다 같이 일하자~ 서로서로 죽었는지 감시하자~


# 운영체제의 작동
하드웨어 인터럽트와 소프트웨어 인터럽트

## 다중 프로그래밍과 다중 태스킹
메모리에 여러 개의 프로세스를 올리고 번갈아가면서 수행. 한 프로세스가 계속 계산작업을 수행하는 것은 아니므로, 번갈아가면서 쇽쇽쇽 처리.
여기서 가상메모리 개념이 살짝 나오는데, 프로그램 코드 겁나 큼. 근데 이거 메모리에 다 올리면 공간 부족함. 그래서 일부만 메모리에 적재하고, 찾...아가나? 

## 이중모드
사용자가 중요한 하드웨어 자원에 접근하는 것을 막기 위해 사용자모드와 커널모드로 나누어져있음. 시스템 콜을 통해 사용자 모드에서 커널모드로 전환가능.

커널 모드는 특권 모드라고 부르기도 하고, 커널 모드가 수행하는 명령을 특권 명령이라고 하기도 함. (ex. 타이머 사용 - 응용 프로그램이 무한 루프에 빠지는 걸 막기위해 사용자 모드가 작업중이면 타이머를 사용해 수행 시간에 제어를 걸 수 있음. 타이머에 지정된 시간을 넘겼는데도 사용자 모드에서 작업중이면 인터럽트 발생.)

## 자원 관리
### 프로세스 관리 
* 프로세스 생성 & 제거
* CPU에 프로세스와 스레드 스케줄
* 프로세스 일시 중지 & 재수행
* 프로세스 동기화 지원
* 프로세스 통신 지원

### 메모리 관리
* 메모리의 특정 주소에 할당된 애가 누군지 추적 가능
* 메모리에 프로세스를 적재 & 제거
   * 어떤 기준으로 적재하고 제거할 것인가?

### 파일 시스템 관리
* 파일 또는 디렉토리 생성 & 삭제
* 파일을 보조기억장치와 매핑(파일은 논리적인 저장 단위이다.)

### 대용량 저장장치 관리
(얘는 물리적인 관점)
* 사용 가능 공간 관리
* 저장
* 디스크 스케줄링
* 저장장치 분할
* 보호(는 유저모드 커널모드 말하는 거임?)

### 캐시 관리
소프트웨어 캐시 관리
* 하드웨어로 구현된 캐시도 있으나 얘는 운영체제가 제어할 수 없음. 시스템 대부분이 미리 예상되는 명령을 넣어둔 명령 캐시를 가지고 있다.
* 캐시로부터 레지스터로의 데이터 전송은 운영체제의 간섭없이 하드웨어적으로 이루어진다? 반면 디스크와 메모리 간의 데이터 전송은 운영체제에 의해 제어된다?


### 입출력 시스템 관리
* 버퍼링, 캐싱을 포함한 메모리 관리 구성요소
* 장치 드라이버 인터페이스 (하드웨어 장치의 특성을 인터페이스를 사용해 숨김)

### 보안과 보호
* 앞서 말한 유저모드/커널모드가 보호를 위한 것. 보안은 악의적인 공격에 의해 사용자 정보가 털리는 것을 막기 위한 것. 

# 가상화
하드웨어를 여러 개의 실행 환경으로 추상화해서 제공하는 것. 별도의 실행 환경들이 존재하는 것 같지만 사실은 전부 다 같은 하드웨어를 사용하고 있단다~ 


갈수록 내용이 짧아지는 건 착각입니다
