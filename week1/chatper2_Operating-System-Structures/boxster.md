# Chapter 2. 운영체제 구조

## 2.1 운영체제 서비스

- **입출력 연산**: 운영체제는 입출력 실행의 수단을 제공 (사용자가 직접 조작할 수 없음)
- **프로그램 실행**: 프로그램을 메모리에 적재하여 실행
- **자원 할당**: 다수의 작업들이 동시에 실행될 때, 그들 각각에 적절히 자원을 할당
- **파일 시스템 조작**: 파일 생성, 수정, 삭제, 권한 등을 조작
- **통신**: 공유 메모리나 메시지 전달 등 프로세스간의 통신 구현
- **회계**: 자원을 얼마나 사용했는지 기록하고 관리 (서비스 개선 등의 목적)
- **오류 탐지**: 항상 올바르고 일관성 있는 계산을 보장
- **보호**: 시스템 자원에 대한 모든 접근이 통제되도록 보장
- **사용자 인터페이스**: UI는 `CLI`, `Batch파일`, `GUI` 등 다양한 형태로 제공
- **보안**: 부적절한 외부 접근 차단 및 침입 탐지

## 2.2 사용자 운영체제 인터페이스

- **CLI**: 사용자가 명령어를 직접 입력. (bash, csh, zsh …)
- **GUI**: 마우스 기반 윈도우 메뉴 시스템

## 2.3 시스템콜

**API**

응용 프로그래머는 다음과 같은 이유로 API를 통해 간접적으로 시스템을 호출하며 프로그램을 구현:

- 인터페이스만 알면 됨
- 프로그램 호환성

## 2.4 시스템 서비스 

운영체제는 프로그램 개발과 실행을 위해 더 편리한 환경을 제공하도록 도움을 주는 시스템 유틸리티 즉, 시스템 서비스를 제공. 

- **파일 관리:** 파일과 디렉터리를 생성, 삭제, 복사, 개명, 인쇄, 열거 등 일반적인 조작들을 제공.
- **상태 정보:** 시스템의 날짜, 시간, 사용 가능한 메모리와 디스크의 공간의 양, 사용자 수 등과 같은 상태 정보를 제공.
- **파일 변경:** 디스크 혹은 다른 저장장치의 파일의 내용을 생성하고 변경한다. 문장 편집기를 사용할 수 있다.
- **프로그래밍 언어 지원:** 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거, 인터프리터가 종종 운영체제와 함께 사용자에게 제공되거나 별도로 다운받을 수 있다.
- **프로그램 적재와 실행:** 프로그램이 실행되기 위해서는 메모리에 적재되어야 한다. 그를 위한 절대 로더, 재배치 가능 로더, 링키지 에디터와 중첩 로드등을 제공할 수 있다.
- **통신:** e-mail, remote login 등을 통해 통신 관련 서비스를 제공.
- **백그라운드 서비스:**: 부트할 때 특정 시스템 프로그램을 시작시킴.

## 2.5 링커와 로더 

1. 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 된다.
2. **링커** 가 relocatable object 파일을 하나의 이진 실행 파일로 결합한다.
3. **로더** 가 이진 실행 파일을 메모리에 적재하여 CPU 코어에서 실행할 수 있는 상태로 만든다.

위와 같은 링크 및 로드와 관련된 활동은 재배치로, 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다.

동적 링킹 라이브러리는 프로그램이 적재될 때 라이브러리를 동적으로 링크할 수 있게 하여 같은 라이브러리를 사용하는 파일들은 불러온 라이브러리를 공유할 수 있게 된다. (메모리 사용을 크게 절약 가능)

## 2.8 운영체제 구조 

### 2.8.1 모놀리식 구조 

커널과 시스템 프로그램 두 부분으로 구성. 모든 명령들이 커널이 많은 권한을 가지고 있기 때문에, 많은 명령어들이 커널에서 처리됨. 많은 부분이 커널로 이루어지기 때문에 구현 및 확장하기 힘듦.
하지만 시스템 콜 인터페이스에는 오버헤드가 거의 없고, 커널 안에서의 통신 속도가 빠르다는 성능 면에서의 뚜렷한 이점 때문에 여전히 UNIX, Linux, Windows 운영체제에서 이 구조를 사용.

### 2.8.2 계층적 접근

시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 주는 밀접하게 결합된 모놀리식에 대한 대안으로 느슨하기 결합된 시스템.
운영체제가 몇 개의 계층으로 나뉘어져 있고, 각 계층마다 독립적으로 작동. 계층들이 각자 독립적이기 때문에 구현과 디버깅이 간단.
하지만 각 계층의 기능을 적절히 정의해야 하는 문제가 있고 사용자 프로그램이 여러 계층을 통과해야 운영체제 서비스를 얻을 수 있어 성능면에서도 열악.

### 2.8.3 마이크로커널 

모든 중요하지 않은 구성요소를 커널로부터 제거, 
그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구현하는 방법. 
모든 새로운 서비스는 사용자 공간에 추가되기 때문에 커널을 변경할 필요가 없어 운영체제의 확장이 쉬움.
또한 서비스 대부분이 사용자 프로세스로 실행되기 때문에 더욱 높은 보안성과 신뢰성 제공.

### 2.8.4 모듈 

적재가능 커널 모듈(LKM)기법에서는 커널은 핵심적인 구성요소의 집합을 가지고 있고, 
부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있음.
커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서는 계층 구조를 닮았지만, 
모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층구조보다 유연.
중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서 마이크로커널과 유사, 
통신하기 위해 메세지 전달을 호출할 필요가 없기 때문에 더 효율적.

### 2.8.5 하이브리드 시스템 

다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조.
엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 없고 하이브리드 구조를 많이 사용.

## 2.9 운영체제 빌딩과 부팅 

### 2.9.1 운영체제 생성 

운영체제를 처음부터 생성(또는 빌딩)하는 경우

1. 운영체제 소스 코드를 작성.
2. 운영체제가 실행될 시스템의 운영체제를 구성.
    - 어떤 기능이 포함되는지 명시.
3. 운영체제를 컴파일.
4. 운영체제를 설치.
5. 컴퓨터와 새 운영체제를 부팅.

### 2.9.2 시스템 부트 

커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅

1. 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾음.
2. 커널이 메모리에 적재되고 시작.
3. 커널은 하드웨어를 초기화.
4. 루트 파일 시스템이 마운트.
