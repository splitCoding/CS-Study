# 운영체제 구조

## 운영체제가 제공하는 것

- 프로그램 실행 환경을 제공한다.
- 프로그램과 프로그램의 사용자에게 특정 서비스를 제공한다.

### 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 하는 서비스

- 사용자 인터페이스
    - GUI ( 그래픽 사용자 인터페이스 )
    - CLI ( 명령어 라인 인터페이스 ) 혹은 명령 인터프리터 제공
    - 터치 스크린 인터페이스
- 프로그램을 수행
    - 프로그램을 메모리에 적재해 실행
    - 프로그램의 실행을 끝냄
- 입출력 연산을 수행
    - 수행 중인 프로그램은 입출력을 요구
    - 운영체제는 입출력 수행의 수단을 제공
- 파일 시스템 조작 ( 운영체제 별로 다양한 파일 시스템을 제공 )
    - 프로그램은 파일을 읽고 쓴다.
    - 이름에 의해 파일을 생성, 삭제, 조회 한다.
    - 파일의 정보를 열거한다.
- 통신
    - 같은 컴퓨터의 프로세스들끼리 통신한다.
    - 네트워크에 의해 묶여 있는 다른 컴퓨터들의 프로세스끼리 통신한다.
    - 통신 방법
        - 공유 메모리를 통한 통신
        - 메시지 전달 기법을 통한 통신
- 오류 탐지
    - 가능한 모든 오류를 항상 의식한다.
    - 각 유형의 오류에 대해 적당한 조치한다.

### 시스템 자체의 효율적인 동작을 보장하기 위한 기능

- 자원 할당
    - 다수의 프로세스나 작업이 동시에 실행될 때 각각 자원을 할당한다.
        - 예시 : CPU 스케쥴링 루틴은 CPU 속도, 실행해야 할 프로세스, CPU 처리 코어의 개수 등을 고려해 CPU를 최대한 효율적으로 사용하게 한다.
- 기록 작성
    - 어떤 프로그램이 어떤 자원을 얼마나 많이 사용하는지 추적할 수 있다.
    - 서비스를 개선하기 위한 자료를 제공한다.
- 보호와 보안
    - 보호 : 시스템 자원에 대한 모든 접근이 통제되도록 보장
    - 보안 : 외부 입출력 장치들을 부적절한 접근 시도로부터 지키고 침입을 탐지하기 위해 접속들을 기록
    - 다중 사용자 컴퓨터 시스템이나 네트워크로 연결된 컴퓨터 시스템에서 정보의 소유자에게 정보의 사용을 통제할 수 있게 한다.
    - 여러 프로세스가 병행하게 수행될 때 한 프로세스가 다른 프로세스나 운영체제를 방해하지 않도록 한다.

## 사용자와 운영체제 인터페이스

### CLI, 명령 인터프리터

- 사용자가 운영체제가 수행할 명령어를 직접 입력할 수 있도록 한다.
- 사용자가 지정한 명령을 통해서 작업을 수행한다.
    - 명령 처리 방식
        - 인터프리터 자체가 사용자가 지정한 명령을 실행할 코드를 가진 경우
        - 시스템 프로그램에 의해 대부분의 명령을 구현한 경우
            - 인터프리터는 실행될 파일을 식별하기 위해 명령을 사용한다.
                - 예시 : `rm file.txt` 명령어는 `rm` 파일을 찾아서 메모리에 적재하고 `file.txt` 를 매개변수로 전달한다.
            - 새로운 명령을 쉽게 추가할 수 있는 장점이 있다.
- GUI 를 통해 사용할 수 없는 시스템의 기능을 사용할 수 있다.
- 자주 사용 되는 작업을 파일로 저장하여 프로그램을 실행하는 것처럼 이용할 수 있다.
    - 이를 Shell Script 라고 한다.
- 대부분 운영체제가 명령 인터프리터를 프로세스가 시작되거나 사용자가 처음 로그인할 때 수행하는 특수한 프로그램으로 취급한다.

### GUI 인터페이스

### 터치스크린 인터페이스

## 시스템 콜

- 운영체제에 의해 사용 가능한 서비스에 대한 인터페이스를 제공
    - 일반적으로 C, C++ 언어로 작성된 함수 형태로 제공된다.

### API ( 응용 프로그래밍 인터페이스 )

- 각 함수에 전달되어야 매개변수들과 기대하는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.
- 간단한 프로그램이라도 운영체제의 기능을 아주 많이 사용하기에 초당 수천개의 시스템 콜을 수행하게 되는데 사용자는 API를 사용하기에 이를 알지 못한다.
    - 대부분의 응용 개발자 들은 API 에 따라 프로그램을 설계한다.
    - API 에 따라 프로그래밍을 통해서 프로그램의 호환성을 얻을 수 있다.
    - 프로그램상에서 작업하기가 시스템콜이 더 어렵다.

### RTE ( 실행 시간 환경 )

- 시스템 콜을 처리하는데 있어 중요한 요소로 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는데 필요한 소프트웨어 제품군, 라이브러리, 로더 같은 다른 소프트웨어를 함께 가리킨다.
- 운영체제가 제공하는 시스템 콜에 대한 역할고리 역할을 하는 시스템 콜 인터페이스를 제공한다.
    - 시스템 콜 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다.
    - 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다.
- 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API 에 의해 프로그래머로부터 숨겨지고 RTE에 의해 관리된다.

### 시스템 콜의 유형

- 프로세스 제어
    - 프로세스 끝내기, 프로세스 중지
    - 프로세스 적재, 프로세스 수행
    - 프로세스 생성, 프로세스 종료
    - 프로세스 속성 획득, 프로세스 속성 설정
    - 이벤트 대기, 이벤트 알림
    - 메모리 할당 및 자유화
    - 시간 기다림
    - 프로세스들끼리 데이터를 공유할 때 공유된 데이터의 일관성을 보장하기 위해서 프로세스가 공유 데이터를 잠글 수 있는 시스템콜을 제공한다.
- 파일 관리
    - 파일 생성, 파일 삭제
    - 파일 열기, 파일 닫기
    - 읽기, 쓰기, 위치 변경
    - 파일 속성 획득 및 설정
- 장치 관리
    - 장치를 요구, 방출
    - 읽기, 쓰기, 위치 변경
    - 장치 속성 획득 및 설정
    - 장치의 논리적 부착, 분리
    - 운영체제에 의해 제어되는 다양한 자원들을 장치로 간주될 수 있으며 프로세스가 작업을 계속 수행하기 위해 필요한 자원들을 할당해주거나 기다리게 할 수 있다.
- 정보 유지
    - 시간과 날짜의 설정과 획득
    - 시스템 데이터의 설정과 획득
    - 프로세스, 파일, 장치 속성의 획득 및 설정
    - 많은 시스템 콜이 사용자 프로그램과 운영체제 간의 정보 전달을 위해 존재한다.
- 통신
    - 통신 연결의 생성, 제거
    - 메시지의 송신, 수신
    - 상태 정보 전달
    - 원격 장치의 부탁 및 분리
    - 통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다.
        - 메시지 전달
            - 통신이 이루이기 전에 연결이 되어야 한다.
            - 컴퓨터는 호스트 이름을, 프로세스는 프로세스 이름을 식별자로 가진다.
            - 위에 식별자를 통해서 운영체제가 프로세스를 가리킨다.
            - 소량의 데이터를 교환할 때 유용하다.
        - 공유 메모리 모델
            - 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막으려고 한다.
            - 공유 메모리는 두 개 이상의 프로세스가 이런 제약을 제거하는데 동의할 것을 필요로 한다.
            - 프로세스는 동일한 위치에 동시에 쓰지 않도록 보장할 책임을 진다.
            - 한 컴퓨터 안에서 메모리 전송 속도로 수행할 수 있기에 최대 속도와 편리한 통신을 허용하지만 보호, 동기화 부분에서 문제점을 가진다.
- 보호
    - 컴퓨터 시스템이 제공하는 자원에 대한 권한 조회, 설정
    - 네트워킹과 인터넷의 출현으로 다수의 사용자를 가지는 다중 프로그램 시스템뿐만 아니라 서버부터 휴대용 컴퓨터까지 모든 컴퓨터 시스템에서 보호를 고려해야 한다.

## 시스템 서비스 ( 시스템 유틸리티 )

- 현대 시스템의 또 다른 면은 시스템 서비스의 집약체이다.
- 시스템 서비스는 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.
    - 파일 관리
    - 상태 정보
    - 파일 변경
    - 프로그래밍 언어지원
    - 프로그램 적재와 수행
    - 통신
    - 백그라운드 서비스
        - 모든 범용 시스템은 부트할 때 특정 프로그램을 시작시킬 수 있는 방법을 가지고 있다.
            - 할 일이 완료되면 종료되는 프로세스
            - 시스템이 정지될 때까지 계속해서 실행되는 프로세스

### 일반적인 연산을 수행하는 유용한 프로그램

- 웹브라우저, 워드 프로세서, 텍스트 포맷터, 스프레드 시트 등등

사용자 대부분이 보는 운영체제의 관점은 시스템 콜보다는 시스템 프로그램과 응용 프로그램에 의해 정의된다.

## 링커와 로더

- 프로그램은 디스크에 이진 실행 파일로 존재한다.
- CPU 에서 실행하기 위해 프로그램을 메모리로 가져와 프로세스 형태로 배치해야 한다.
1. 소스 파일은 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 된다. ( 재배치 가능 오브젝트 파일 )
2. 링커는 재배치 가능 오브젝트 파일들을 하나의 이진 실행 파일로 결합한다.
3. 로더는 이진 실행 파일을 메모리에 적재한다.
    - CPU 코어에서 실행할 수 있는 상태가 된다.
- 링크 및 로드와 관련된 활동을 재배치라고 한다.
    - 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 하여 프로그램이 실행될 때 코드가 함수를 호출하고 변수에 접근할 수 있게 한다.
    - Unix 에서 실행시 ( ex. `./main` )
        1. fork() 시스템 콜로 프로그램을 실행하기 위한 새 프로세스를 생성한다.
        2. exec() 시스템 콜로 로더를 호출하고 실행 파일 이름을 전달한다. ( main )
        3. 로더는 지정된 프로그램을 생성된 프로세스의 주소공간을 사용하여 메모리에 적재한다.
- 동적 링킹 라이브러리 ( DLL )
    - DLL 은 프로그램이 적재될 때 라이브러리를 동적으로 링크하게 한다.
    - 라이브러리는 조건부로 링크되며 프로그램 실행 시간에 필요한 경우 적재된다.
        - 실행 파일에서 사용되지 않을 수 있는 라이브러리를 링크, 로드 하지 않는다.
        - 동적으로 링크되고 적재될 수 있도록 재배치 정보를 삽입한다.
            - 동적으로 링크된 라이브러리를 여러 프로세스가 공유할 수 있기에 메모리 사용이 크게 절약된다.
    - 오브젝트 파일 및 실행 파일은 일반적으로 표준화된 형식을 가진다.
        - Unix, Linux 에서 ELF 형식 이라고 하여 ELF 파일의 정보 중 하나는 프로그램의 실행할 때 실행할 첫번째 명령어의 주소가 저장되어 있는 `시작점`이다.

## 응용 프로그램이 운영체제마다 다른 이유

- 각 운영체제는 고유한 시스템 콜 집합을 제공하기 때문이다.
- 각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식을 가진다.
    - 이런 구성요소는 명시된 구조 형태로 실행 파일 내의 특정 위치에 있어야 운영체제가 파일을 열고 응용 프로그램을 적재하여 올바르게 실행할 수 있다.

### ABI ( Applicatoin Binary Interface )

- 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는 방법을 정의하는 인터페이스로 아키텍처 수준의 API 이다.
- 특정 아키텍처에서 실행되는 특정 운영체제에 대한 ABI 가 정의되어 있기에 ABI 는 플랫폼 간 호환성을 거의 제공하지 않는다.

## 운영체제의 구현

- 운영체제가 작성되어 있는 언어는 모두 다르다.
    - 커널은 대부분 어셈블리 언어와 C 를 사용한다.
- 운영체제를 구현하기 위해 고급언어나 최소한의 시스템 구현 언어 사용시 장단점
    - 장점
        - 코드를 빨리 작성할 수 있고, 간결하고, 이해하기 쉽고, 디버깅이 쉽다.
        - 컴파일러 기술의 향상이 운영체제를 위해 생성된 코드의 향상까지 이어진다.
    - 단점
        - 고급 수준 언어로 구현했을 때 속도가 느리고 저장 장치가 많이 소요되는 단점이 있다.
        - 이는 현재 시스템에서 주된 문제는 아니며 운영체제의 주요 성능 향상은 우수한 어셈블리어 보다 좋은 자료구조와 알고리즘의 결과일 가능성이 크다. 즉 소량의 코드의 고성능이 중요하다.
            - 인터럽트 핸들러, 입출력 관리자, 메모리 관리자, CPU 스케줄러 등등

## 운영체제 구조

- 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있도록 신중히 제작되어야 한다.
    - 이를 위해 한개의 일관된 시스템보다는 작은 구성요소로 분할할 수 있다.

### 모놀리식 구조

- 구조가 아예 없으며 운영체제를 구성하는 가장 간단하고 일반적인 구조이다.
- 밀접하게 결합된 시스템이라고 불린다.
- 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는다.

### 모듈화 구조

- 한 구성요소의 변경이 다른 구성요소에 영향을 미치지 않기에 내부 작동을 더 자유롭게 생성하고 변경할 수 있다.

### 계층적 접근 방식

- 운영체제가 여러 개의 층으로 나누어진다.
    1. 하드웨어 계층
    2. … 계층
    3. … 계층
    4. 사용자 인터페이스 계층
- 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해서 구성한다.
- 각 계층의 기능을 적절하게 정의하여 나누어야 한다.
- 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드가 발생한다.

### 마이크로 커널

- 중요하지 않은 모든 구성요소를 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 커널에서 제거하여 커널을 작게 만든다.
- 장점
    - 운영체제의 확장이 쉽다.
    - 서비스 대부분이 사용자 프로세스로 수행되기 때문에 높은 보안성과 신뢰성을 제공한다.
- 단점
    - 사용자 수준 서비스가 통신해야 하는 경우 서로 다른 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다.
    - 메시지 교환을 위해 프로세스를 다음 프로세스로 전환해야 할 수 있다.
    - 위에 두가지로 인한 오버헤드가 발생한다.

### 모듈

적재가능 커널 모듈 (Loadable Kernel Modules) 기법

- 커널은 핵심 서비스만 제공한다
- 부팅 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크한다.
- 현대 UNIX 를 구현하는 일반적인 유형의 설계이다.
- 장점
    - 동적으로 링크함으로써 수정 사항이 생길 때마다 커널을 다시 컴파일하지 않아도 된다.
    - 모듈에서 다른 모듈을 호출할 수 있기에 통신을 위해서 메시지 전달을 호출할 필요가 없다.

### 하이브리드 시스템

- 운영체제는 하나의 구조를 택하지 않고 다양한 구조를 결합하여 성능, 보안, 편리성 문제를 해결하는 구조로 구성된다.

## 운영체제 빌딩과 부팅

- 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서도 실행되도록 설계된다.

### 시스템 부트

- 커널을 적재하여 컴퓨터를 시작하는 과정을 시스템 부팅이라고 한다.
- 하드웨어가 운영체제를 사용하기 위해서 하드웨어가 커널의 위치나 커널을 적재하는 방법을 알아야 한다.
    1. 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾는다.
    2. 커널이 메모리에 적재되고 시작된다.
    3. 커널은 하드웨어를 초기화 한다.
    4. 루트 파일 시스템이 마운트 된다.
- 다단계 부팅 과정
    1. BIOS 라고 하는 비휘발성 펌웨어에 있는 소형 부트 로더가 실행된다.
    2. 초기 부트 로더는 일반적으로 부트 블록이라고 하는 디스크의 정해진 위치에 있는 두번째 부트 로더를 적재한다.
        - 일반적으로 부트 로더는 하나의 디스크 블록에 저장되어야 하기에 간단한 코드로서 디스크의 주소와 부트스트랩 프로그램 나머지의 길이만 알고 있다.
        - 부트 블록에 저장된 프로그램은 전체 운영체제를 메모리에 적재하고 실행할 수 있을 만큼 정교할 수도 있다.
- UEFI ( Unified Extensible Firmware Interface )
    - UEFI 가 하나의 완전한 부팅 관리자이기에 부팅 과정이 더 빠르다.
    - 64비트 시스템과 용량이 큰 디스크를 더 잘 지원한다.
- 부트스트랩 프로그램
    - 커널 프로그램이 포함된 파일을 메모리에 적재한다.
    - 진단을 실시하여 메모리와 CPU를 점검한다.
    - 장치 검색과 같은 시스템 상태를 확인한다.
    - 시스템의 모든 측면을 초기화 할 수 있다.
    - 진단을 통과하면 프로그램은 부팅 과정을 계속 진행하여 운영체제를 시작하고 루트 파일 시스템을 마운트 하는데 이 시점에서 시스템을 실행 중이라고 할 수 있다.
- Linux
    - 공간을 절약하고 부팅 시간을 줄이기 위해 Linux 커널 이미지는 압축 파일이며 메모리에 적재된 후 압축이 풀어진다.
    - 부팅 과정에서 부트 로더는 일반적으로 initramfs 로 알려진 임시 RAM 파일 시스템을 생성한다.
    - 커널이 시작되고 필요한 드라이버가 설치되면 커널은 루트 파일 시스템을 임시 RAM 위치에서 적절한 루트 파일 시스템 위치로 전환한다.
    - 마지막으로 초기 프로세스인 systemd 프로세스를 생성한 다음 다른 서비스를 시작한다.
- 부트 메커니즘은 부트 로더와 매우 연관되어 있다.
- 대부분의 운영체제의 부트 로더는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할 수 있는 복구모드, 단일 사용자 모드로 부팅할 수 있는 기능을 제공한다.

## 운영체제 디버깅

### 장애 분석

- 프로세스가 실패할 경우
    - 문제가 발생함을 경고하기 위해 오류 정보를 로그 파일에 기록한다.
    - 프로세스가 사용하던 메모를 캡처한 코어(초기 메모리를 칭하던 용어) 덤프를 파일로 저장한다.
- 커널 장애는 crash 라고 불리며 이 또한 로그가 기록되고 메모리 상태가 crash 덤프에 저장된다.
- 파일 시스템 코드 때문에 발생한 crash 는 재부팅 전에 커널의 상태를 파일 시스템에 저장하려는 위험한 시도를 한다.
    - 일반적으로 커널의 메모리 상태를 예약된 파일 시스템을 가지지 않은 디스크의 특정 부분에 저장한다.
    - 특정 디스크 영역에 메모리 전체 내용 혹은 시스템 메모리의 커널이 소유한 부분만이라도 저장한다.
    - 재부팅시 이 영역에서 데이터를 수집하고 파일 시스템의 crash 덤프 파일로 기록한다.

### 성능 관찰

- 운영체제는 일련의 카운터를 통해 시스템 활동을 추적한다.
    - ps : 프로세스 정보
    - top : 프로세스에 대한 실시간 통계
    - vmstat : 메모리 사용량 통계
    - netstat : 네트워크 인터페이스에 대한 통계
    - iostat : 디스크의 I/O 사용량

### 추적

- 추적 도구는 특정 이벤트에 대한 데이터를 수집한다.
    - strace : 프로세스에 의해 호출된 시스템 콜  데이터
    - gdb - 프로세스 소스 레벨 디버거
    - perf - 리눅스 성능 도구 모음
    - tcpdump - 네트워크 패킷 수집
